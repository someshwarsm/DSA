#########   Returning Length     ########

public int lengthOfLIS(int[] nums) {
    int n = nums.length;
    int[] dp = new int[n];
    int max=1;
    dp[0]=1;
    for(int i=1;i<n;i++){
        dp[i]=1;
        for(int j=0;j<i;j++){
            if(nums[i]>nums[j]){
                dp[i]=Math.max(dp[i], 1+dp[j]);
            }
        }
        max = Math.max(max, dp[i]);
    }
    return max;
}



#########     Returning Subsequence     ##########

public ArrayList<Integer> longestIncreasingSubsequence(int n, int nums[]) {
    int[] dp = new int[n];
    int[] indexArr = new int[n];
    dp[0]=1;
    int max=1, maxIndex=0;
    indexArr[0]=-1;
    for(int i=1;i<n;i++){
        dp[i]=1;
        for(int j=i-1;j>=0;j--){
            if(nums[i]>nums[j]){
                dp[i]=Math.max(dp[i], 1+dp[j]);
                if(dp[i]==1+dp[j]){
                    indexArr[i]=j;
                }
            }
        }
        if(max<dp[i]){
            max=dp[i];
            maxIndex=i;
        }
    }
    
    ArrayList<Integer> l = new ArrayList<>();
    
    while(max!=0){
        l.add(nums[maxIndex]);
        maxIndex = indexArr[maxIndex];
        max--;
    }
    
    Collections.reverse(l);
    
    return l;
}